Motivation:
    - Constructors do not convey intent because they
     must be named after a class.
    - Particularly a problem when there are many constructors
    in a class
    - leads to dead constructors
Solution
    - static or non-static creation methods
    - name the clearly expresses intent
    - also may be necessary to extract a subclass
Limitation
    - Some classes are instantiated with new and some are not
    Non-standard


Mechanics

First: Find a catch-all constructor. If you do not have one,
consider the Chain Constructors pattern

1. Find a client that calls a constructor to create a kind
of instance. Apply extract method. Now move the method to the
class.

2. Find all callers of the chosen constructor that create
the same kind of instance and have them call the new creation
method.

3. If the constructor is chained to another constructor,
make the new creation method call the chained constructor

4. Rinse and Repeat

5. If the catch-all constructor now has no external clients,
make it private

Example
Banking. Consider Loan.java. Loan.java has many constructors.

Term Loan = must be paid in full by its maturity date
Revolver = credit, revolving credit - has a spending limit and an expiry date
Revolving credit term loan = a revolver that transforms into a term limit when
    revolver expires

Uses a strategy to calculate payments for the loan.

The code makes little of the different loan types clear.
I happen to know that an RCTL needs both an expiry date
and a maturity date, so I know that to create an RCTL,
I must call a constructor that lets me pass in both dates.
Did you know that? Do you think the next programmer who
reads this code will know it?

If you call the first constructor, which takes three parameters,
you’ll get back a term loan. But if you want a revolver,
you’ll need to call one of the constructors that take two dates
and then supply null for the maturity date.
I wonder if all users of this code will know this?
Or will they just have to learn by encountering some ugly defects?

So step 1. find a client. I have written some tests to have a
client. Also then I can easily refactor the code.